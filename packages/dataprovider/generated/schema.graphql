### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Address {
  city: String
  countryCode: String
  street: String
}

type AffectedRowsOutput {
  count: Int!
}

type BlogPost {
  author: User
  comments(cursor: BlogPostCommentWhereUniqueInput, skip: Int, take: Int): [BlogPostComment!]!
  id: String!
  text: String!
  title: String!
}

type BlogPostComment {
  author: User
  id: String!
  post: BlogPost
  text: String!
}

input BlogPostCommentCreateInput {
  author: UserCreateNestedOneWithoutCommentsInput
  id: String
  post: BlogPostCreateNestedOneWithoutCommentsInput
  text: String!
}

input BlogPostCommentCreateManyAuthorInput {
  id: String
  postId: String
  text: String!
}

input BlogPostCommentCreateManyAuthorInputEnvelope {
  data: [BlogPostCommentCreateManyAuthorInput!]
  skipDuplicates: Boolean
}

input BlogPostCommentCreateManyPostInput {
  authorId: String
  id: String
  text: String!
}

input BlogPostCommentCreateManyPostInputEnvelope {
  data: [BlogPostCommentCreateManyPostInput!]
  skipDuplicates: Boolean
}

input BlogPostCommentCreateNestedManyWithoutAuthorInput {
  connect: [BlogPostCommentWhereUniqueInput!]
  connectOrCreate: [BlogPostCommentCreateOrConnectWithoutAuthorInput!]
  create: [BlogPostCommentCreateWithoutAuthorInput!]
  createMany: BlogPostCommentCreateManyAuthorInputEnvelope
}

input BlogPostCommentCreateNestedManyWithoutPostInput {
  connect: [BlogPostCommentWhereUniqueInput!]
  connectOrCreate: [BlogPostCommentCreateOrConnectWithoutPostInput!]
  create: [BlogPostCommentCreateWithoutPostInput!]
  createMany: BlogPostCommentCreateManyPostInputEnvelope
}

input BlogPostCommentCreateOrConnectWithoutAuthorInput {
  create: BlogPostCommentCreateWithoutAuthorInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentCreateOrConnectWithoutPostInput {
  create: BlogPostCommentCreateWithoutPostInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentCreateWithoutAuthorInput {
  id: String
  post: BlogPostCreateNestedOneWithoutCommentsInput
  text: String!
}

input BlogPostCommentCreateWithoutPostInput {
  author: UserCreateNestedOneWithoutCommentsInput
  id: String
  text: String!
}

input BlogPostCommentListRelationFilter {
  every: BlogPostCommentWhereInput
  none: BlogPostCommentWhereInput
  some: BlogPostCommentWhereInput
}

input BlogPostCommentOrderByRelationAggregateInput {
  count: SortOrder!
}

input BlogPostCommentOrderByWithRelationInput {
  author: UserOrderByWithRelationInput
  authorId: SortOrder
  id: SortOrder
  post: BlogPostOrderByWithRelationInput
  postId: SortOrder
  text: SortOrder
}

input BlogPostCommentScalarWhereInput {
  AND: [BlogPostCommentScalarWhereInput!]
  NOT: [BlogPostCommentScalarWhereInput!]
  OR: [BlogPostCommentScalarWhereInput!]
  authorId: StringNullableFilter
  id: StringFilter
  postId: StringNullableFilter
  text: StringFilter
}

input BlogPostCommentUpdateInput {
  author: UserUpdateOneWithoutCommentsInput
  id: StringFieldUpdateOperationsInput
  post: BlogPostUpdateOneWithoutCommentsInput
  text: StringFieldUpdateOperationsInput
}

input BlogPostCommentUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
}

input BlogPostCommentUpdateManyWithWhereWithoutAuthorInput {
  data: BlogPostCommentUpdateManyMutationInput!
  where: BlogPostCommentScalarWhereInput!
}

input BlogPostCommentUpdateManyWithWhereWithoutPostInput {
  data: BlogPostCommentUpdateManyMutationInput!
  where: BlogPostCommentScalarWhereInput!
}

input BlogPostCommentUpdateManyWithoutAuthorInput {
  connect: [BlogPostCommentWhereUniqueInput!]
  connectOrCreate: [BlogPostCommentCreateOrConnectWithoutAuthorInput!]
  create: [BlogPostCommentCreateWithoutAuthorInput!]
  createMany: BlogPostCommentCreateManyAuthorInputEnvelope
  delete: [BlogPostCommentWhereUniqueInput!]
  deleteMany: [BlogPostCommentScalarWhereInput!]
  disconnect: [BlogPostCommentWhereUniqueInput!]
  set: [BlogPostCommentWhereUniqueInput!]
  update: [BlogPostCommentUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BlogPostCommentUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [BlogPostCommentUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BlogPostCommentUpdateManyWithoutPostInput {
  connect: [BlogPostCommentWhereUniqueInput!]
  connectOrCreate: [BlogPostCommentCreateOrConnectWithoutPostInput!]
  create: [BlogPostCommentCreateWithoutPostInput!]
  createMany: BlogPostCommentCreateManyPostInputEnvelope
  delete: [BlogPostCommentWhereUniqueInput!]
  deleteMany: [BlogPostCommentScalarWhereInput!]
  disconnect: [BlogPostCommentWhereUniqueInput!]
  set: [BlogPostCommentWhereUniqueInput!]
  update: [BlogPostCommentUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [BlogPostCommentUpdateManyWithWhereWithoutPostInput!]
  upsert: [BlogPostCommentUpsertWithWhereUniqueWithoutPostInput!]
}

input BlogPostCommentUpdateWithWhereUniqueWithoutAuthorInput {
  data: BlogPostCommentUpdateWithoutAuthorInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentUpdateWithWhereUniqueWithoutPostInput {
  data: BlogPostCommentUpdateWithoutPostInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentUpdateWithoutAuthorInput {
  id: StringFieldUpdateOperationsInput
  post: BlogPostUpdateOneWithoutCommentsInput
  text: StringFieldUpdateOperationsInput
}

input BlogPostCommentUpdateWithoutPostInput {
  author: UserUpdateOneWithoutCommentsInput
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
}

input BlogPostCommentUpsertWithWhereUniqueWithoutAuthorInput {
  create: BlogPostCommentCreateWithoutAuthorInput!
  update: BlogPostCommentUpdateWithoutAuthorInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentUpsertWithWhereUniqueWithoutPostInput {
  create: BlogPostCommentCreateWithoutPostInput!
  update: BlogPostCommentUpdateWithoutPostInput!
  where: BlogPostCommentWhereUniqueInput!
}

input BlogPostCommentWhereInput {
  AND: [BlogPostCommentWhereInput!]
  NOT: [BlogPostCommentWhereInput!]
  OR: [BlogPostCommentWhereInput!]
  author: UserWhereInput
  authorId: StringNullableFilter
  id: StringFilter
  post: BlogPostWhereInput
  postId: StringNullableFilter
  text: StringFilter
}

input BlogPostCommentWhereUniqueInput {
  id: String
}

input BlogPostCreateInput {
  author: UserCreateNestedOneWithoutBlogPostsInput
  comments: BlogPostCommentCreateNestedManyWithoutPostInput
  id: String
  text: String!
  title: String!
}

input BlogPostCreateManyAuthorInput {
  id: String
  text: String!
  title: String!
}

input BlogPostCreateManyAuthorInputEnvelope {
  data: [BlogPostCreateManyAuthorInput!]
  skipDuplicates: Boolean
}

input BlogPostCreateNestedManyWithoutAuthorInput {
  connect: [BlogPostWhereUniqueInput!]
  connectOrCreate: [BlogPostCreateOrConnectWithoutAuthorInput!]
  create: [BlogPostCreateWithoutAuthorInput!]
  createMany: BlogPostCreateManyAuthorInputEnvelope
}

input BlogPostCreateNestedOneWithoutCommentsInput {
  connect: BlogPostWhereUniqueInput
  connectOrCreate: BlogPostCreateOrConnectWithoutCommentsInput
  create: BlogPostCreateWithoutCommentsInput
}

input BlogPostCreateOrConnectWithoutAuthorInput {
  create: BlogPostCreateWithoutAuthorInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostCreateOrConnectWithoutCommentsInput {
  create: BlogPostCreateWithoutCommentsInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostCreateWithoutAuthorInput {
  comments: BlogPostCommentCreateNestedManyWithoutPostInput
  id: String
  text: String!
  title: String!
}

input BlogPostCreateWithoutCommentsInput {
  author: UserCreateNestedOneWithoutBlogPostsInput
  id: String
  text: String!
  title: String!
}

input BlogPostListRelationFilter {
  every: BlogPostWhereInput
  none: BlogPostWhereInput
  some: BlogPostWhereInput
}

input BlogPostOrderByRelationAggregateInput {
  count: SortOrder!
}

input BlogPostOrderByWithRelationInput {
  author: UserOrderByWithRelationInput
  authorId: SortOrder
  comments: BlogPostCommentOrderByRelationAggregateInput
  id: SortOrder
  text: SortOrder
  title: SortOrder
}

input BlogPostScalarWhereInput {
  AND: [BlogPostScalarWhereInput!]
  NOT: [BlogPostScalarWhereInput!]
  OR: [BlogPostScalarWhereInput!]
  authorId: StringNullableFilter
  id: StringFilter
  text: StringFilter
  title: StringFilter
}

input BlogPostUpdateInput {
  author: UserUpdateOneWithoutBlogPostsInput
  comments: BlogPostCommentUpdateManyWithoutPostInput
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input BlogPostUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input BlogPostUpdateManyWithWhereWithoutAuthorInput {
  data: BlogPostUpdateManyMutationInput!
  where: BlogPostScalarWhereInput!
}

input BlogPostUpdateManyWithoutAuthorInput {
  connect: [BlogPostWhereUniqueInput!]
  connectOrCreate: [BlogPostCreateOrConnectWithoutAuthorInput!]
  create: [BlogPostCreateWithoutAuthorInput!]
  createMany: BlogPostCreateManyAuthorInputEnvelope
  delete: [BlogPostWhereUniqueInput!]
  deleteMany: [BlogPostScalarWhereInput!]
  disconnect: [BlogPostWhereUniqueInput!]
  set: [BlogPostWhereUniqueInput!]
  update: [BlogPostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BlogPostUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [BlogPostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BlogPostUpdateOneWithoutCommentsInput {
  connect: BlogPostWhereUniqueInput
  connectOrCreate: BlogPostCreateOrConnectWithoutCommentsInput
  create: BlogPostCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: BlogPostUpdateWithoutCommentsInput
  upsert: BlogPostUpsertWithoutCommentsInput
}

input BlogPostUpdateWithWhereUniqueWithoutAuthorInput {
  data: BlogPostUpdateWithoutAuthorInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostUpdateWithoutAuthorInput {
  comments: BlogPostCommentUpdateManyWithoutPostInput
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input BlogPostUpdateWithoutCommentsInput {
  author: UserUpdateOneWithoutBlogPostsInput
  id: StringFieldUpdateOperationsInput
  text: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input BlogPostUpsertWithWhereUniqueWithoutAuthorInput {
  create: BlogPostCreateWithoutAuthorInput!
  update: BlogPostUpdateWithoutAuthorInput!
  where: BlogPostWhereUniqueInput!
}

input BlogPostUpsertWithoutCommentsInput {
  create: BlogPostCreateWithoutCommentsInput!
  update: BlogPostUpdateWithoutCommentsInput!
}

input BlogPostWhereInput {
  AND: [BlogPostWhereInput!]
  NOT: [BlogPostWhereInput!]
  OR: [BlogPostWhereInput!]
  author: UserWhereInput
  authorId: StringNullableFilter
  comments: BlogPostCommentListRelationFilter
  id: StringFilter
  text: StringFilter
  title: StringFilter
}

input BlogPostWhereUniqueInput {
  id: String
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumGenderNullableFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderNullableFilter
  notIn: [Gender!]
}

input EnumTopicNullableListFilter {
  equals: [Topic!]
  has: Topic
  hasEvery: [Topic!]
  hasSome: [Topic!]
  isEmpty: Boolean
}

type FilteringTest {
  boolField: Boolean!
  dateTimeField: DateTime!
  floatField: Float!
  id: Int!
  intField: Int!
  intField_bt: Int!
  intField_lt: String!
  snake_field: Int!
  snake_field_bt: Int!
  stringField: String!
}

input FilteringTestCreateInput {
  boolField: Boolean!
  dateTimeField: DateTime!
  floatField: Float!
  intField: Int!
  intField_bt: Int!
  intField_lt: String!
  snake_field: Int!
  snake_field_bt: Int!
  stringField: String!
}

input FilteringTestOrderByWithRelationInput {
  boolField: SortOrder
  dateTimeField: SortOrder
  floatField: SortOrder
  id: SortOrder
  intField: SortOrder
  intField_bt: SortOrder
  intField_lt: SortOrder
  snake_field: SortOrder
  snake_field_bt: SortOrder
  stringField: SortOrder
}

input FilteringTestUpdateInput {
  boolField: BoolFieldUpdateOperationsInput
  dateTimeField: DateTimeFieldUpdateOperationsInput
  floatField: FloatFieldUpdateOperationsInput
  intField: IntFieldUpdateOperationsInput
  intField_bt: IntFieldUpdateOperationsInput
  intField_lt: StringFieldUpdateOperationsInput
  snake_field: IntFieldUpdateOperationsInput
  snake_field_bt: IntFieldUpdateOperationsInput
  stringField: StringFieldUpdateOperationsInput
}

input FilteringTestUpdateManyMutationInput {
  boolField: BoolFieldUpdateOperationsInput
  dateTimeField: DateTimeFieldUpdateOperationsInput
  floatField: FloatFieldUpdateOperationsInput
  intField: IntFieldUpdateOperationsInput
  intField_bt: IntFieldUpdateOperationsInput
  intField_lt: StringFieldUpdateOperationsInput
  snake_field: IntFieldUpdateOperationsInput
  snake_field_bt: IntFieldUpdateOperationsInput
  stringField: StringFieldUpdateOperationsInput
}

input FilteringTestWhereInput {
  AND: [FilteringTestWhereInput!]
  NOT: [FilteringTestWhereInput!]
  OR: [FilteringTestWhereInput!]
  boolField: BoolFilter
  dateTimeField: DateTimeFilter
  floatField: FloatFilter
  id: IntFilter
  intField: IntFilter
  intField_bt: IntFilter
  intField_lt: StringFilter
  snake_field: IntFilter
  snake_field_bt: IntFilter
  stringField: StringFilter
}

input FilteringTestWhereUniqueInput {
  id: Int
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

enum Gender {
  FEMALE
  MALE
  OTHER
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

scalar Json

input JsonNullableFilter {
  equals: Json
  not: Json
}

type Mutation {
  createOneBlogPost(data: BlogPostCreateInput!): BlogPost!
  createOneBlogPostComment(data: BlogPostCommentCreateInput!): BlogPostComment!
  createOneFilteringTest(data: FilteringTestCreateInput!): FilteringTest!
  createOneSomePublicRecordWithIntId(data: SomePublicRecordWithIntIdCreateInput!): SomePublicRecordWithIntId!
  createOneUser(data: UserCreateInput!): User!
  createOneUserRole(data: UserRoleCreateInput!): UserRole!
  deleteManyBlogPost(where: BlogPostWhereInput): AffectedRowsOutput!
  deleteManyBlogPostComment(where: BlogPostCommentWhereInput): AffectedRowsOutput!
  deleteManyFilteringTest(where: FilteringTestWhereInput): AffectedRowsOutput!
  deleteManySomePublicRecordWithIntId(where: SomePublicRecordWithIntIdWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyUserRole(where: UserRoleWhereInput): AffectedRowsOutput!
  deleteOneBlogPost(where: BlogPostWhereUniqueInput!): BlogPost
  deleteOneBlogPostComment(where: BlogPostCommentWhereUniqueInput!): BlogPostComment
  deleteOneFilteringTest(where: FilteringTestWhereUniqueInput!): FilteringTest
  deleteOneSomePublicRecordWithIntId(where: SomePublicRecordWithIntIdWhereUniqueInput!): SomePublicRecordWithIntId
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneUserRole(where: UserRoleWhereUniqueInput!): UserRole
  updateManyBlogPost(data: BlogPostUpdateManyMutationInput!, where: BlogPostWhereInput): AffectedRowsOutput!
  updateManyBlogPostComment(data: BlogPostCommentUpdateManyMutationInput!, where: BlogPostCommentWhereInput): AffectedRowsOutput!
  updateManyFilteringTest(data: FilteringTestUpdateManyMutationInput!, where: FilteringTestWhereInput): AffectedRowsOutput!
  updateManySomePublicRecordWithIntId(data: SomePublicRecordWithIntIdUpdateManyMutationInput!, where: SomePublicRecordWithIntIdWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyUserRole(data: UserRoleUpdateManyMutationInput!, where: UserRoleWhereInput): AffectedRowsOutput!
  updateOneBlogPost(data: BlogPostUpdateInput!, where: BlogPostWhereUniqueInput!): BlogPost
  updateOneBlogPostComment(data: BlogPostCommentUpdateInput!, where: BlogPostCommentWhereUniqueInput!): BlogPostComment
  updateOneFilteringTest(data: FilteringTestUpdateInput!, where: FilteringTestWhereUniqueInput!): FilteringTest
  updateOneSomePublicRecordWithIntId(data: SomePublicRecordWithIntIdUpdateInput!, where: SomePublicRecordWithIntIdWhereUniqueInput!): SomePublicRecordWithIntId
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneUserRole(data: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole
  upsertOneBlogPost(create: BlogPostCreateInput!, update: BlogPostUpdateInput!, where: BlogPostWhereUniqueInput!): BlogPost!
  upsertOneBlogPostComment(create: BlogPostCommentCreateInput!, update: BlogPostCommentUpdateInput!, where: BlogPostCommentWhereUniqueInput!): BlogPostComment!
  upsertOneFilteringTest(create: FilteringTestCreateInput!, update: FilteringTestUpdateInput!, where: FilteringTestWhereUniqueInput!): FilteringTest!
  upsertOneSomePublicRecordWithIntId(create: SomePublicRecordWithIntIdCreateInput!, update: SomePublicRecordWithIntIdUpdateInput!, where: SomePublicRecordWithIntIdWhereUniqueInput!): SomePublicRecordWithIntId!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneUserRole(create: UserRoleCreateInput!, update: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumGenderNullableFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderNullableFilter
  notIn: [Gender!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableEnumGenderFieldUpdateOperationsInput {
  set: Gender
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  blogPost(where: BlogPostWhereUniqueInput!): BlogPost
  blogPostComment(where: BlogPostCommentWhereUniqueInput!): BlogPostComment
  blogPostComments(cursor: BlogPostCommentWhereUniqueInput, orderBy: [BlogPostCommentOrderByWithRelationInput!], skip: Int, take: Int, where: BlogPostCommentWhereInput): [BlogPostComment!]!
  blogPostCommentsCount(cursor: BlogPostCommentWhereUniqueInput, orderBy: BlogPostCommentOrderByWithRelationInput, skip: Int, take: Int, where: BlogPostCommentWhereInput): Int
  blogPosts(cursor: BlogPostWhereUniqueInput, orderBy: [BlogPostOrderByWithRelationInput!], skip: Int, take: Int, where: BlogPostWhereInput): [BlogPost!]!
  blogPostsCount(cursor: BlogPostWhereUniqueInput, orderBy: BlogPostOrderByWithRelationInput, skip: Int, take: Int, where: BlogPostWhereInput): Int
  filteringTest(where: FilteringTestWhereUniqueInput!): FilteringTest
  filteringTests(cursor: FilteringTestWhereUniqueInput, orderBy: [FilteringTestOrderByWithRelationInput!], skip: Int, take: Int, where: FilteringTestWhereInput): [FilteringTest!]!
  filteringTestsCount(cursor: FilteringTestWhereUniqueInput, orderBy: FilteringTestOrderByWithRelationInput, skip: Int, take: Int, where: FilteringTestWhereInput): Int
  somePublicRecordWithIntId(where: SomePublicRecordWithIntIdWhereUniqueInput!): SomePublicRecordWithIntId
  somePublicRecordWithIntIds(cursor: SomePublicRecordWithIntIdWhereUniqueInput, orderBy: [SomePublicRecordWithIntIdOrderByWithRelationInput!], skip: Int, take: Int, where: SomePublicRecordWithIntIdWhereInput): [SomePublicRecordWithIntId!]!
  somePublicRecordWithIntIdsCount(cursor: SomePublicRecordWithIntIdWhereUniqueInput, orderBy: SomePublicRecordWithIntIdOrderByWithRelationInput, skip: Int, take: Int, where: SomePublicRecordWithIntIdWhereInput): Int
  user(where: UserWhereUniqueInput!): User
  userRole(where: UserRoleWhereUniqueInput!): UserRole
  userRoles(cursor: UserRoleWhereUniqueInput, orderBy: [UserRoleOrderByWithRelationInput!], skip: Int, take: Int, where: UserRoleWhereInput): [UserRole!]!
  userRolesCount(cursor: UserRoleWhereUniqueInput, orderBy: UserRoleOrderByWithRelationInput, skip: Int, take: Int, where: UserRoleWhereInput): Int
  users(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  usersCount(cursor: UserWhereUniqueInput, orderBy: UserOrderByWithRelationInput, skip: Int, take: Int, where: UserWhereInput): Int
}

enum QueryMode {
  default
  insensitive
}

type SomePublicRecordWithIntId {
  id: Int!
  title: String!
}

input SomePublicRecordWithIntIdCreateInput {
  title: String!
}

input SomePublicRecordWithIntIdOrderByWithRelationInput {
  id: SortOrder
  title: SortOrder
}

input SomePublicRecordWithIntIdUpdateInput {
  title: StringFieldUpdateOperationsInput
}

input SomePublicRecordWithIntIdUpdateManyMutationInput {
  title: StringFieldUpdateOperationsInput
}

input SomePublicRecordWithIntIdWhereInput {
  AND: [SomePublicRecordWithIntIdWhereInput!]
  NOT: [SomePublicRecordWithIntIdWhereInput!]
  OR: [SomePublicRecordWithIntIdWhereInput!]
  id: IntFilter
  title: StringFilter
}

input SomePublicRecordWithIntIdWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

enum Topic {
  TOPIC_ONE
  TOPIC_THREE
  TOPIC_TWO
}

type User {
  address: Address
  blogPosts(cursor: BlogPostWhereUniqueInput, skip: Int, take: Int): [BlogPost!]!
  comments(cursor: BlogPostCommentWhereUniqueInput, skip: Int, take: Int): [BlogPostComment!]!
  email: String!
  firstName: String
  gender: Gender
  id: String!
  interests: [Topic!]!
  lastName: String
  logs(from: String!, to: String!): [String]
  roles(cursor: UserRoleWhereUniqueInput, skip: Int, take: Int, where: UserRoleWhereInput): [UserRole!]!
  userSocialMedia: UserSocialMedia
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateInput {
  address: Json
  blogPosts: BlogPostCreateNestedManyWithoutAuthorInput
  comments: BlogPostCommentCreateNestedManyWithoutAuthorInput
  email: String!
  firstName: String
  gender: Gender
  id: String
  interests: UserCreateinterestsInput
  lastName: String
  roles: UserRoleCreateNestedManyWithoutUsersInput
  userSocialMedia: UserSocialMediaCreateNestedOneWithoutUserInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateNestedManyWithoutRolesInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutRolesInput!]
  create: [UserCreateWithoutRolesInput!]
}

input UserCreateNestedOneWithoutBlogPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutBlogPostsInput
  create: UserCreateWithoutBlogPostsInput
}

input UserCreateNestedOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
}

input UserCreateOrConnectWithoutBlogPostsInput {
  create: UserCreateWithoutBlogPostsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRolesInput {
  create: UserCreateWithoutRolesInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutBlogPostsInput {
  address: Json
  comments: BlogPostCommentCreateNestedManyWithoutAuthorInput
  email: String!
  firstName: String
  gender: Gender
  id: String
  interests: UserCreateinterestsInput
  lastName: String
  roles: UserRoleCreateNestedManyWithoutUsersInput
  userSocialMedia: UserSocialMediaCreateNestedOneWithoutUserInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateWithoutCommentsInput {
  address: Json
  blogPosts: BlogPostCreateNestedManyWithoutAuthorInput
  email: String!
  firstName: String
  gender: Gender
  id: String
  interests: UserCreateinterestsInput
  lastName: String
  roles: UserRoleCreateNestedManyWithoutUsersInput
  userSocialMedia: UserSocialMediaCreateNestedOneWithoutUserInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateWithoutRolesInput {
  address: Json
  blogPosts: BlogPostCreateNestedManyWithoutAuthorInput
  comments: BlogPostCommentCreateNestedManyWithoutAuthorInput
  email: String!
  firstName: String
  gender: Gender
  id: String
  interests: UserCreateinterestsInput
  lastName: String
  userSocialMedia: UserSocialMediaCreateNestedOneWithoutUserInput
  wantsNewsletter: Boolean!
  yearOfBirth: Int
}

input UserCreateinterestsInput {
  set: [Topic!]
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByRelationAggregateInput {
  count: SortOrder!
}

input UserOrderByWithRelationInput {
  address: SortOrder
  blogPosts: BlogPostOrderByRelationAggregateInput
  comments: BlogPostCommentOrderByRelationAggregateInput
  email: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  interests: SortOrder
  lastName: SortOrder
  roles: UserRoleOrderByRelationAggregateInput
  userSocialMedia: UserSocialMediaOrderByWithRelationInput
  wantsNewsletter: SortOrder
  yearOfBirth: SortOrder
}

type UserRole {
  id: String!
  name: String!
}

input UserRoleCreateInput {
  id: String
  name: String!
  users: UserCreateNestedManyWithoutRolesInput
}

input UserRoleCreateNestedManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  connectOrCreate: [UserRoleCreateOrConnectWithoutUsersInput!]
  create: [UserRoleCreateWithoutUsersInput!]
}

input UserRoleCreateOrConnectWithoutUsersInput {
  create: UserRoleCreateWithoutUsersInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleCreateWithoutUsersInput {
  id: String
  name: String!
}

input UserRoleListRelationFilter {
  every: UserRoleWhereInput
  none: UserRoleWhereInput
  some: UserRoleWhereInput
}

input UserRoleOrderByRelationAggregateInput {
  count: SortOrder!
}

input UserRoleOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  users: UserOrderByRelationAggregateInput
}

input UserRoleScalarWhereInput {
  AND: [UserRoleScalarWhereInput!]
  NOT: [UserRoleScalarWhereInput!]
  OR: [UserRoleScalarWhereInput!]
  id: StringFilter
  name: StringFilter
}

input UserRoleUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  users: UserUpdateManyWithoutRolesInput
}

input UserRoleUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input UserRoleUpdateManyWithWhereWithoutUsersInput {
  data: UserRoleUpdateManyMutationInput!
  where: UserRoleScalarWhereInput!
}

input UserRoleUpdateManyWithoutUsersInput {
  connect: [UserRoleWhereUniqueInput!]
  connectOrCreate: [UserRoleCreateOrConnectWithoutUsersInput!]
  create: [UserRoleCreateWithoutUsersInput!]
  delete: [UserRoleWhereUniqueInput!]
  deleteMany: [UserRoleScalarWhereInput!]
  disconnect: [UserRoleWhereUniqueInput!]
  set: [UserRoleWhereUniqueInput!]
  update: [UserRoleUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [UserRoleUpdateManyWithWhereWithoutUsersInput!]
  upsert: [UserRoleUpsertWithWhereUniqueWithoutUsersInput!]
}

input UserRoleUpdateWithWhereUniqueWithoutUsersInput {
  data: UserRoleUpdateWithoutUsersInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleUpdateWithoutUsersInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input UserRoleUpsertWithWhereUniqueWithoutUsersInput {
  create: UserRoleCreateWithoutUsersInput!
  update: UserRoleUpdateWithoutUsersInput!
  where: UserRoleWhereUniqueInput!
}

input UserRoleWhereInput {
  AND: [UserRoleWhereInput!]
  NOT: [UserRoleWhereInput!]
  OR: [UserRoleWhereInput!]
  id: StringFilter
  name: StringFilter
  users: UserListRelationFilter
}

input UserRoleWhereUniqueInput {
  id: String
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  address: JsonNullableFilter
  email: StringFilter
  firstName: StringNullableFilter
  gender: EnumGenderNullableFilter
  id: StringFilter
  interests: EnumTopicNullableListFilter
  lastName: StringNullableFilter
  wantsNewsletter: BoolFilter
  yearOfBirth: IntNullableFilter
}

type UserSocialMedia {
  id: String!
  instagram: String!
  twitter: String!
  user: User!
}

input UserSocialMediaCreateNestedOneWithoutUserInput {
  connect: UserSocialMediaWhereUniqueInput
  connectOrCreate: UserSocialMediaCreateOrConnectWithoutUserInput
  create: UserSocialMediaCreateWithoutUserInput
}

input UserSocialMediaCreateOrConnectWithoutUserInput {
  create: UserSocialMediaCreateWithoutUserInput!
  where: UserSocialMediaWhereUniqueInput!
}

input UserSocialMediaCreateWithoutUserInput {
  id: String
  instagram: String!
  twitter: String!
}

input UserSocialMediaOrderByWithRelationInput {
  id: SortOrder
  instagram: SortOrder
  twitter: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input UserSocialMediaUpdateOneWithoutUserInput {
  connect: UserSocialMediaWhereUniqueInput
  connectOrCreate: UserSocialMediaCreateOrConnectWithoutUserInput
  create: UserSocialMediaCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: UserSocialMediaUpdateWithoutUserInput
  upsert: UserSocialMediaUpsertWithoutUserInput
}

input UserSocialMediaUpdateWithoutUserInput {
  id: StringFieldUpdateOperationsInput
  instagram: StringFieldUpdateOperationsInput
  twitter: StringFieldUpdateOperationsInput
}

input UserSocialMediaUpsertWithoutUserInput {
  create: UserSocialMediaCreateWithoutUserInput!
  update: UserSocialMediaUpdateWithoutUserInput!
}

input UserSocialMediaWhereInput {
  AND: [UserSocialMediaWhereInput!]
  NOT: [UserSocialMediaWhereInput!]
  OR: [UserSocialMediaWhereInput!]
  id: StringFilter
  instagram: StringFilter
  twitter: StringFilter
  user: UserWhereInput
  userId: StringFilter
}

input UserSocialMediaWhereUniqueInput {
  id: String
}

input UserUpdateInput {
  address: Json
  blogPosts: BlogPostUpdateManyWithoutAuthorInput
  comments: BlogPostCommentUpdateManyWithoutAuthorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  gender: NullableEnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  interests: UserUpdateinterestsInput
  lastName: NullableStringFieldUpdateOperationsInput
  roles: UserRoleUpdateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaUpdateOneWithoutUserInput
  wantsNewsletter: BoolFieldUpdateOperationsInput
  yearOfBirth: NullableIntFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  address: Json
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  gender: NullableEnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  interests: UserUpdateinterestsInput
  lastName: NullableStringFieldUpdateOperationsInput
  wantsNewsletter: BoolFieldUpdateOperationsInput
  yearOfBirth: NullableIntFieldUpdateOperationsInput
}

input UserUpdateManyWithWhereWithoutRolesInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutRolesInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutRolesInput!]
  create: [UserCreateWithoutRolesInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRolesInput!]
  updateMany: [UserUpdateManyWithWhereWithoutRolesInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRolesInput!]
}

input UserUpdateOneWithoutBlogPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutBlogPostsInput
  create: UserCreateWithoutBlogPostsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutBlogPostsInput
  upsert: UserUpsertWithoutBlogPostsInput
}

input UserUpdateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateWithWhereUniqueWithoutRolesInput {
  data: UserUpdateWithoutRolesInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutBlogPostsInput {
  address: Json
  comments: BlogPostCommentUpdateManyWithoutAuthorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  gender: NullableEnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  interests: UserUpdateinterestsInput
  lastName: NullableStringFieldUpdateOperationsInput
  roles: UserRoleUpdateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaUpdateOneWithoutUserInput
  wantsNewsletter: BoolFieldUpdateOperationsInput
  yearOfBirth: NullableIntFieldUpdateOperationsInput
}

input UserUpdateWithoutCommentsInput {
  address: Json
  blogPosts: BlogPostUpdateManyWithoutAuthorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  gender: NullableEnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  interests: UserUpdateinterestsInput
  lastName: NullableStringFieldUpdateOperationsInput
  roles: UserRoleUpdateManyWithoutUsersInput
  userSocialMedia: UserSocialMediaUpdateOneWithoutUserInput
  wantsNewsletter: BoolFieldUpdateOperationsInput
  yearOfBirth: NullableIntFieldUpdateOperationsInput
}

input UserUpdateWithoutRolesInput {
  address: Json
  blogPosts: BlogPostUpdateManyWithoutAuthorInput
  comments: BlogPostCommentUpdateManyWithoutAuthorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  gender: NullableEnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  interests: UserUpdateinterestsInput
  lastName: NullableStringFieldUpdateOperationsInput
  userSocialMedia: UserSocialMediaUpdateOneWithoutUserInput
  wantsNewsletter: BoolFieldUpdateOperationsInput
  yearOfBirth: NullableIntFieldUpdateOperationsInput
}

input UserUpdateinterestsInput {
  push: Topic
  set: [Topic!]
}

input UserUpsertWithWhereUniqueWithoutRolesInput {
  create: UserCreateWithoutRolesInput!
  update: UserUpdateWithoutRolesInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutBlogPostsInput {
  create: UserCreateWithoutBlogPostsInput!
  update: UserUpdateWithoutBlogPostsInput!
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: JsonNullableFilter
  blogPosts: BlogPostListRelationFilter
  comments: BlogPostCommentListRelationFilter
  email: StringFilter
  firstName: StringNullableFilter
  gender: EnumGenderNullableFilter
  id: StringFilter
  interests: EnumTopicNullableListFilter
  lastName: StringNullableFilter
  roles: UserRoleListRelationFilter
  userSocialMedia: UserSocialMediaWhereInput
  wantsNewsletter: BoolFilter
  yearOfBirth: IntNullableFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
